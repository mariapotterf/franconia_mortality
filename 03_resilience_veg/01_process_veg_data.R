

# Read vegetation data 
# collected during field work 2022
# by Juri Majerand and Sophia Storbeck

# Process: -----------------------------
# Read the data by weeks
# order the data by the columns by the german names: master name is Week 3 [ENG]
# bin the data by rows
# replace by ENG names to creates groups of data: 
#         inner:
#            - ground cover, regen, advanced regen
#         outer:
#            - distance to trees, tree density 

# Output: ------------------------------
# density: regen
#          advanced regen
#          get the share of teh planted
#          share of damaged and location of damage
# density:
#          mature trees: calculate based on the distance to nearest tree
# 
# 
# photo indication: north subplot
#                   south subplot
#                   north, east, south, west environment
# video indication:  north, east, south, west environment
# export individual dataframes for subsequent processing: shannon, community traits...


# Data structure -----------------------------------
# each record in the Table field has its own columns: ~ 600 columns
# Regeneration: tree regeneration is split across tree species, height classes and damage
# each tree species in height class: has 7 columns
# 6 heights levels: 6*7 = 42 columns per species
# 

#### Colnames interpretation --------------------------------------
# if 'env' - surroundings (environment)
# if not env - in the site 
# completed unique names for tree, species, etc.


# remove all previous data from R memory
rm(list=ls())


# Regeneration Tree species (12 species in total):
# 
#Spruce
#Beech
#Rowan
#Fir
#Oak
#Maple
#Birch
#Willow
#Pine
#Ash
#Other hardwood
#Other softwood 

reg_trees <- c(
  'Spruce',         # Picea abies
  'Beech',          # Fagus sylvatica
  'Rowan',          # Sorbus sp
  'Fir',            # Abies alba
  'Oak',            # Quercus sp.  
  'Maple',          # Acer pseudoplatanus
  'Birch',          # Betula pendula
  'Willow',         # Salix sp.
  'Pine',           # Pinus sylvestris
  'Ash',            # Fraxinus excelsior 
  'OtherHardwood',  # list of other species: in rhe Other_species.xlsx shared by Juri
  'OtherSoftwood'
)


# the 'Other species':

# species_name	Latin	                Species	      DE-name
# Hornbeam	    Carpinus betulus	    OtherHardwood	Hbu
# Cherry	      Prunus avium        	OtherHardwood	Kirche
# Cherry	      Prunus padus	        OtherHardwood	Kirche
# Norway Maple	Acer platanoides	    OtherHardwood	SAH
# Field Maple	  Acer campestre	      OtherHardwood	
# Ilex	        Ilex aquifolium	      OtherHardwood	
# Linden	      Tilia Cordata	        OtherHardwood	
# Douglas	      Pseudotsuga menziesii	OtherSoftwood	
# Larch	        Larix decidua	        OtherSoftwood	
# Checker Tree	Sorbus torminalis	    OtherHardwood	Wallnuss
# Walnut	      Juglans regia	        OtherHardwood	
# Alder	        Alnus glutinosa	      OtherHardwood	
# Poplar	      Populus tremula	      OtherHardwood	
# Whitebeam	    Sorbus aria	          OtherHardwood	



# Deadwood: from the ground cover [%],
# from the ENV: 
#   - standing deadwood 
#   - lying deadwood 
#   - stump
#   - root plate
#  vars: distance, species [conif/dec], no dbh


# Input data -------------------------------------------------------------------
#### Source paths and functions  -----------------------------------------------

setwd('C:/Users/ge45lep/Documents/2021_Franconia_mortality/r_franconia_mortality')
source('myPaths.R')


#### Read libraries  -----------------------------------------------------------
library(readxl)
library(psych)     # for short summary statistics
library(dplyr)
library(data.table)
library(tidyr)
library(ggplot2)
library(stringr)  # use regex expressions
library(tidyverse) # contains readr to read the csv data as tibble



#### Read Regeneration data -----------------------------------------------------
dat1  <- read_excel(paste(myPath, inFolderFieldVeg, "Data_Week_3.xlsx", sep = '/'))
dat2  <- read_excel(paste(myPath, inFolderFieldVeg, "Data_Week_1-2.xlsx", sep = '/'))
dat3  <- read_excel(paste(myPath, inFolderFieldVeg, "Data_Week_4.xlsx", sep = '/'))
dat4  <- read_excel(paste(myPath, inFolderFieldVeg, "Data_Week_5-6.xlsx", sep = '/'))
dat5  <- read_excel(paste(myPath, inFolderFieldVeg, "Data_Week_7-8.xlsx", sep = '/'))



# Read Other species data - regeneration  ----------------------------------------
# created manually from the Notes material: need to read the data and 
# replace the regeneration counts for 'OtherDeciduous' and 'OtherConiferous' in 
# in the df_regen counts
df_other_regen   = readr::read_csv2(paste(myPath, 
                                      outTable,"dat_notes_mod.csv", sep = '/'))  


#### Name output tables ---------------------------------------------------------
outDat            = paste(myPath, outTable, 'dat_full.csv'              , sep = '/')  # contains infor of plantation& damage
outDatNotes       = paste(myPath, outTable, 'dat_notes.csv'             , sep = '/')  # extract notes about regeneration

outRegen          = paste(myPath, outTable, 'df_regen.csv'              , sep = '/')  # contains infor of plantation& damage
outRegenAdvanced  = paste(myPath, outTable, 'df_regen_advanced.csv'     , sep = '/')
outMaturePlot     = paste(myPath, outTable, 'df_mature_trees_plot.csv'  , sep = '/')
outMatureENV      = paste(myPath, outTable, 'df_mature_trees_env.csv'   , sep = '/')
outAdvancedENV    = paste(myPath, outTable, 'df_advanced_env.csv'       , sep = '/')

outGround                 = paste(myPath, outTable, 'df_ground.csv'  , sep = '/')
outDeadwood               = paste(myPath, outTable, 'df_deadwood.csv', sep = '/')  # get deadwood volume estimation
outVideo                  = paste(myPath, outTable, 'df_video.csv'   , sep = '/')
outPhoto                  = paste(myPath, outTable, 'df_photo.csv'   , sep = '/')
outPhotoVideoNearestTree  = paste(myPath, outTable, 'df_photo_video_nearTree.csv' , sep = '/')
  


# Identify the exposition numbers: reconstruct the sectors and check how well they fit???
# because somethings the trees seems not correctly aligned the the snapshot?
north = 315-360 & 0-45
east  = 45-135
south = 135-225
west  = 225-315 


## Clean input data -------------------------------------------------------------
# Read New headings: in ENG, with unique colnames 
# this was done manually in Excel
EN_heading <- read_excel(paste(myPath, 
                               inFolderFieldVeg, 
                                "col_names_ENG.xlsx", sep = '/'), 
                          sheet = "en_name")  # sheet name

# check if teh colnames are equal??
#names(dat1) == names(dat2)
#names(dat1) == names(dat3)
#names(dat1) == names(dat4)
#names(dat1) == names(dat5)

# If the names are the same, we can bind them together
dat <- rbind(dat1, dat2, dat3, dat4, dat5)




# Check if the columns lenght is the same:
ncol(dat)         # 617
nrow(EN_heading)  # 617

# Remove the spaces from the En_heading, replace some not important characters
EN_col_names <- gsub(' ', '_',    EN_heading$ENG)
EN_col_names <- gsub('_in_', '_', EN_col_names)
EN_col_names <- gsub('\\.', '',   EN_col_names) # . means any character, so need to add \\


# Replace the naming to have unique name for each colums 
# and be able to filter throught them
colnames(dat) <- EN_col_names

unique(dat$General_remarks)  # remarks contains the info about tree species : O_hardwood or O_softwood; not all trees are explicit
unique(dat$Remarks_on_regeneration) # only info about regeneration: # remarks contains the info about tree species : O_hardwood or O_softwood


# Create unique ID per site:
dat <- dat %>% 
  mutate(uniqueID = paste(trip_n,dom_sp,manag,sub_n, sep = '_' )) #%>%

# keep all sites: total number of plots:  1244
# some can be later removed: no vegetation, too far from the near trees (> 15 m away...)
# get master table containing all combination of the plots per sites: 
plot_counts_df <-
  dat %>% 
  select(uniqueID) %>% 
  separate(uniqueID, c('trip_n', 'dom_sp', 'manag', 'sub_n'), '_') 
 
# get their sums: how many plots per site?
plot_counts_df_sum <- plot_counts_df %>% 
  group_by(trip_n, dom_sp, manag) %>%
  tally()


#### Export the full table in wide format
fwrite(dat, outDat)


# check !!! on Aug 19th: check the regeneration species of the 42-d-5 ??? it is spruce, but should be oak!!!
#dat %>% 
#  filter(trip_n == 42 & sub_n == 5)  %>% 
#  dplyr::select(matches(c('Spruce', 'Oak', 'uniqueID'))) #%>% replaced amnually in week 1-2! 

# dat$trip_n <- replace(dat$trip_n, dat$trip_n == 35 &  dat$dom_sp == 'beech', 32) 

#### Correct mistakes/typos (found during processing): --------------------------------------
# need for quality data check! visually in the table, and correct in the script
# from 06/28/2022 -> correct directly in the files
#dat$trip_n <- replace(dat$trip_n, dat$trip_n == 644, 64) 
#dat$trip_n <- replace(dat$trip_n, dat$trip_n == 35 &  dat$dom_sp == 'beech', 32) 
#dat$trip_n <- replace(dat$dom_sp, dat$trip_n == 33 &  dat$dom_sp == 'spruce', 33) # meaning? 10/09/2022 ???
#dat$trip_n <- replace(dat$trip_n, dat$trip_n == 91, 61) 
#dat$trip_n <- replace(dat$trip_n, dat$trip_n == 2 & dat$dom_sp == 'pine', 62) 
#dat$sub_n  <- replace(dat$sub_n,  dat$sub_n == 24, 14) 
#dat$trip_n <- replace(dat$trip_n, dat$trip_n == 65 &  dat$dom_sp == 'beech', 25) 
#dat$trip_n <- replace(dat$trip_n, dat$trip_n == 28 &  dat$dom_sp == 'beech', 25)
#dat$trip_n <- replace(dat$trip_n, dat$trip_n == 15 & dat$dom_sp == 'beech', 'spruce') 
#dat$trip_n <- replace(dat$trip_n, dat$trip_n == 26 , 23) 

# Change distances to nearest Mature trees:
dat$env_Distance_next_MatureTree <- replace(dat$env_Distance_next_MatureTree, 
                                            dat$env_Distance_next_MatureTree == 25, 500) 
dat$env_Distance_next_MatureTree <- replace(dat$env_Distance_next_MatureTree, 
                                            dat$env_Distance_next_MatureTree == 90, 900) 
dat$env_Distance_next_MatureTree <- replace(dat$env_Distance_next_MatureTree, 
                                            dat$env_Distance_next_MatureTree == 14, 140) 
dat$env_Distance_next_MatureTree <- replace(dat$env_Distance_next_MatureTree, 
                                            dat$env_Distance_next_MatureTree == 53, 530) 
dat$env_Distance_next_MatureTree <- replace(dat$env_Distance_next_MatureTree, 
                                            dat$env_Distance_next_MatureTree == 52, 150) 
dat$env_Distance_next_MatureTree <- replace(dat$env_Distance_next_MatureTree, 
                                            dat$env_Distance_next_MatureTree == 44, 440) 
dat$env_Distance_next_MatureTree <- replace(dat$env_Distance_next_MatureTree, 
                                            dat$env_Distance_next_MatureTree == 11, 1100) 


# Change distances to nearest advanced regeneration:
dat$env_Distance_next_Advanced_regeneration <- replace(dat$env_Distance_next_Advanced_regeneration, 
                                            dat$env_Distance_next_Advanced_regeneration == 13160, 150) 
dat$env_Distance_next_Advanced_regeneration <- replace(dat$env_Distance_next_Advanced_regeneration, 
                                                       dat$env_Distance_next_Advanced_regeneration == 71, 171) 
dat$env_Distance_next_Advanced_regeneration <- replace(dat$env_Distance_next_Advanced_regeneration, 
                                                       dat$env_Distance_next_Advanced_regeneration == 40, 400) 
dat$env_Distance_next_Advanced_regeneration <- replace(dat$env_Distance_next_Advanced_regeneration, 
                                                       dat$env_Distance_next_Advanced_regeneration == 50, 15) 


## Check for typos & Get basic statistic ---------------------------------------
# check for triplets numbers, number of subset per site, ...
# sample patches by patch??
# correct then manually in the data themselves
dat %>% 
  group_by(trip_n, dom_sp) %>% 
  tally() %>% 
  arrange(dom_sp) %>% 
  arrange(trip_n) %>% 
  print(n = 50)

# total of 40: 45&65 were not sampled due to missing owner permission

# Get each category size ----------------------------------------------------------------
dat_size  <- read_excel(paste(myPath, '03_plot_sampling/sites_identification/final/share', 
                              "sites_unique_ID.xlsx", 
                              sep = '/'))

# keep only useful columns
dat_size <- 
  dat_size %>% 
  select(Name, Area_m2) %>% 
  separate(Name, c('trip_n', 'dom_sp', 'manag'), '-') %>% 
  mutate(manag = tolower(manag),
         trip_n = as.numeric(trip_n)) 

nrow(dat_size) # 126
nrow(dat)      # 1244

# Join category size with the vegetation data  -------------------------------------------
dat <- dat %>% 
  left_join(dat_size, by = c("trip_n", "dom_sp", "manag"))

dat_size %>% 
  ggplot(aes(Area_m2/10000), fill = 'white', col = 'black') +
  geom_histogram(bins = 100) +
  theme_bw() +
  facet_grid(.~manag)
  


## List important column names from raw table  -------------------------------------------


# Get columns for photos:
photos_id <- c("north_plot",
               "east_plot",
               "north_environment",
               "east_environment",
               "south_environment",
               "west_environment")


# Get columns for the site identification
plot_info <- c(#"ObjectID",
               #"GlobalID",
               "trip_n",
               "dom_sp",
               "manag",
               "sub_n"               )  

# get geographic information
plot_geo <- c("gradient",
              "exposure")



# Export tables for photos & videos  --------------------------------------------------

# Get ID with indication of the photo number
df_photo <-   
  dat %>% 
  dplyr::select(matches(c(plot_info, photos_id, 'uniqueID'))) %>%
   dplyr::select(-all_of(plot_info))  %>%
  pivot_longer(!uniqueID, names_to = 'class', values_to = 'photo_number')  %>%
  separate(class, c('orientation', 'site'), '_') %>% 
  separate(uniqueID, all_of(plot_info), '_')


#### Save the table 
fwrite(df_photo, outPhoto)


# Get ID with indication of the photo number
df_video <-   
  dat %>% 
  dplyr::select(matches(paste(c(plot_info, 'Video', 'uniqueID'), collapse = '|'))) %>% 
  dplyr::select(-c("trip_n","dom_sp","manag",'sub_n'))  %>%
  dplyr::select_if(function(col) all(col == .$uniqueID) | is.numeric(col)) %>%  # select uniqueID and only numeric columns
  pivot_longer(!uniqueID, names_to = 'class', values_to = 'video_number')  %>%
  filter(complete.cases(.)) %>%  # remove the rows that contains NA values 
  separate(class, c('rec_manag', 'site', 'orientation'), '_') %>% 
  separate(uniqueID, c('trip_n', 'dom_sp', 'manag', 'sub_n'), '_')


#### Save the video df 
fwrite(df_video, outVideo)








# Get ground cover shares: per category ------------------------------------------------------
# shows the coverage of teh individual classes: in %
df_ground <-   
  dat %>% 
  dplyr::select(matches(c(plot_info, "gc_", 'uniqueID'))) %>% 
  dplyr::select(-all_of(plot_info)) %>% 
  pivot_longer(!uniqueID, names_to = 'class', values_to = 'prop') %>% 
  mutate(class = gsub('gc_', '', class)) %>% # replace the name indicator
  separate(uniqueID, all_of(plot_info), '_')


#### Save the ground cover table 
fwrite(df_ground, outGround)


# Get deadwood from the ENV -----------------------------------------------
# Standing deadwood
df_DW_standing <- dat %>% 
  dplyr::select(matches(paste(c(plot_info, plot_geo, 'env_'), collapse = '|'))) %>%
  dplyr::select(matches(paste(c(plot_info, plot_geo, 'Standing_deadwood'), 
                              collapse = '|'))) %>%
  dplyr::select(-c("env_Standing_deadwood_present")) %>%
  setnames(c(plot_info, plot_geo, 'orientation', 'species', 'distance')) %>% 
  mutate(DW_type = 'standing')
  
# Lying DW
df_DW_log <- 
  dat %>% 
  dplyr::select(matches(paste(c(plot_info, plot_geo, 'env_'), collapse = '|'))) %>%
  dplyr::select(matches(paste(c(plot_info, plot_geo, 'Lying_deadwood'), 
                              collapse = '|'))) %>%
  dplyr::select(-c("env_Lying_deadwood_present")) %>%
  setnames(c(plot_info, plot_geo, 'orientation', 'species', 'distance')) %>% 
  mutate(DW_type = 'log')


# DW Stump
df_DW_stump <- 
  dat %>% 
  dplyr::select(matches(paste(c(plot_info, plot_geo, 'env_'), collapse = '|'))) %>%
  dplyr::select(matches(paste(c(plot_info, plot_geo, 'stump'), 
                              collapse = '|'))) %>%
  dplyr::select(-c("env_stump_present")) %>%
  setnames(c(plot_info, plot_geo, 'orientation', 'species', 'distance')) %>% 
  mutate(DW_type = 'stump')

# DW root plate
df_DW_plate <- 
  dat %>% 
  dplyr::select(matches(paste(c(plot_info, plot_geo, 'env_'), collapse = '|'))) %>%
  dplyr::select(matches(paste(c(plot_info, plot_geo, 'Root_plate'), 
                              collapse = '|'))) %>%
  dplyr::select(-c("env_Root_plate_present")) %>%
  setnames(c(plot_info, plot_geo, 'orientation', 'species', 'distance')) %>% 
  mutate(DW_type = 'root_plate')


# Merge DW data and correct species and orientation:
df_deadwood <- 
  df_DW_standing %>% 
  bind_rows(df_DW_log) %>% 
  bind_rows(df_DW_stump) %>% 
  bind_rows(df_DW_plate) %>% 
  mutate(species = case_when(species == "Esche"        ~ "Ash",
                             species == "Sonstiges NH" ~ "O_Soft",
                             species == "Sonstiges LH" ~ "O_Hard",
                             species == "Buche"        ~ "Beech" ,
                             species == "Vogelbeere"   ~ "Rowan",
                             species == "Bergahorn"    ~ "Maple",
                             species == "Fichte"       ~ "Spruce",
                             species == "Eiche"        ~ "Oak",
                             species == "Kiefer"       ~ "Pine",
                             species == "Birke"        ~ "Birch",
                             species == "Weide"        ~ "Willow",
                             species == "Tanne"        ~ "Fir",
                             species == "N.A"          ~ NA_character_ )) %>% 
  mutate(orientation = case_when(orientation == 'ost'~ 'east',
                                 orientation == 'west'~ 'west',
                                 orientation == 'nord'~ 'north',
                                 orientation == 'sued'~ 'south')) %>% 
  mutate(distance = case_when(distance == 12 ~ 120,
                              distance != 12 ~ distance)) %>% 
    mutate(trip_n = as.character(trip_n),
           sub_n  = as.character(sub_n))


# check if teh values seems correct?
# gradient, exposition, distances
psych::describe(df_deadwood)

# again some issues with distances:
df_deadwood %>% 
  filter(distance < 100)

# 2      spruce l     6  distance  = 12 -> to 120


#### Save the ground cover table 
fwrite(df_deadwood, outDeadwood)




# get Mature trees on 4m2 plot (live trees > 10 cm dbh) outside of the ground cover shares [%] -------------
# indicates number of mature trees per site (1-4), with species, dbh and height
# at max: two mature trees per 4m2 plot (MatTree_order)
df_mature_trees_plot <-   
  dat %>% 
  dplyr::select(matches(c(plot_info, plot_geo, '_Mature_', 'uniqueID'))) %>% 
  dplyr::select(!matches(c('_subplot', 'gc_Mature_Trees'))) %>%  # remove cols if contains 'subplot' in colname: this only contains YES/NO information
  dplyr::select(-all_of(plot_info)) %>% 
  mutate(across(.fns = as.character)) %>% # convert all values to characters to be able to use pivot_longer
  pivot_longer(!c(uniqueID, gradient, exposure), 
               names_to = 'class', 
               values_to = 'val') %>%
  mutate(class = gsub('_Mature_Trees_', '_', class)) %>%
  separate(class, c('MatTree_order', 'class1'), '_') %>%
  group_by(MatTree_order , class1) %>% 
  mutate(row = row_number()) %>%
  tidyr::pivot_wider(names_from = class1, values_from = val) %>%
  select(-row) %>%
  mutate(
    species = case_when(
      species == "Esche"        ~ "Ash",
      species == "Sonstiges NH" ~ "O_Soft",
      species == "Sonstiges LH" ~ "O_Hard",
      species == "Buche"        ~ "Beech" ,
      species == "Vogelbeere"   ~ "Rowan",
      species == "Bergahorn"    ~ "Maple",
      species == "Fichte"       ~ "Spruce",
      species == "Eiche"        ~ "Oak",
      species == "Kiefer"       ~ "Pine",
      species == "Birke"        ~ "Birch",
      species == "Weide"        ~ "Willow",
      species == "Tanne"        ~ "Fir"
    )) %>% 
  mutate(DBH = as.numeric(DBH),
         Height = as.numeric(Height)) %>% 
  separate(uniqueID, all_of(plot_info), '_')



### Check if the higher gc_tree cover fits with the larger dbh per plot?? ------------------
# subset first the data from both
df_mature_plot2 <- df_mature_trees_plot %>% 
  group_by(trip_n, dom_sp, manag, sub_n) %>% 
  summarize(dbh_sum = sum(DBH, na.rm = T))



#### Save the Mature trees per plot:
fwrite(df_mature_trees_plot, outMaturePlot)

  




# Get Plot: Regeneration data  -----------------------------------------------------

# The regeneration is combined regeneration and advanced regeneration!

# Extract data in several steps:
# Naming: 
# - for regen = seedlings
# - for advanced regen = saplings??
# steps: 
#     select the columns
#     convert them from wide to long format
# planted counts area the counts from the total counts



### For regeneration: seedlings ---------------------------------------------------
# select only columns with Regeneration:
# columns are in different class (logi, num, char), some contains NEIN: characters: need only counts!!!
# if the count is not present, than it is 0

# Subset counts for regeneration dataset
# this number indicates all of teh regeneration: included planted individuals; filters only the the columsn are numeric: select the numbers

df_regen <-
  dat %>%
  dplyr::select(matches(paste(
    c(plot_info, reg_trees, plot_geo, 'uniqueID'), collapse = '|'  #  , 'Remarks_on_regeneration', 'General_remarks'
  ))) %>%
    dplyr::select(!matches("Number")) %>%
  dplyr::select(-all_of(plot_info)) %>%
  dplyr::select_if(function(col)
    all(
        col == .$uniqueID |
        col == .$gradient |
        col == .$exposure |
        is.numeric(col)
    )) %>%  # select the numeric columns and the siteID (character)
#  str()
  pivot_longer(!c(uniqueID, gradient, exposure),  # Remarks_on_regeneration, General_remarks
               names_to = 'manag',
               values_to = 'n_total') %>%
  separate(manag, c('species', 'height_class'), '_') %>%
  separate(uniqueID, all_of(plot_info), '_') #%>%
#filter(n_total !=0)  # keep 0s to have the all overview of the total species
# mutate(origin = 'natural')




# Select the character general remarks on regeneration --------------------
# need to selcted columsn as characters!!
# extracted on 11/08/2022, no need to run
other_sp <- c("OtherHardwood", "OtherSoftwood")

# df_regen_notes <-
#   dat %>%
#   dplyr::select(matches(paste(
#     c(
#       plot_info,
#       other_sp,
#       'uniqueID',
#       'Remarks_on_regeneration',
#       'General_remarks'
#     ),
#     collapse = '|'  #  , 'Remarks_on_regeneration', 'General_remarks'
#   ))) %>%
#   dplyr::select(!matches("Number")) %>%
#   dplyr::select(-all_of(plot_info)) %>%
#   select(which(sapply(., class) == "numeric"),
#          # select several character columns, only 'sapply' works here: https://stackoverflow.com/questions/39592879/r-dpylr-select-if-with-multiple-conditions
#          Remarks_on_regeneration,
#          General_remarks,
#          uniqueID) %>%
#   pivot_longer(
#     !c(uniqueID, Remarks_on_regeneration, General_remarks),
#     # Remarks_on_regeneration, General_remarks
#     names_to = 'manag',
#     values_to = 'n_total'
#   )  %>%
#   separate(manag, c('species', 'height_class'), '_') %>%
#   separate(uniqueID, all_of(plot_info), '_') %>%
#   filter(n_total > 0) %>%
#   # in 'NA' will in with the sciecies type:
#   mutate(Remarks_on_regeneration = case_when(
#     is.na(Remarks_on_regeneration) ~ species,
#     !is.na(Remarks_on_regeneration) ~ Remarks_on_regeneration
#   ))


#unique(df_regen_notes$Remarks_on_regeneration)
#df_regen_notes


# Export df regeneration --------------------------------------------------
# fwrite(df_regen_notes, outDatNotes)



### Fill in the 'Other species': --------------------------------------
# check if to use table from Juri?  'Other_species.xlsx' - check if the counts for other species are ok
# and I can just merge the tables:

# check how to fill in table:
# example: beech: 25 - beech- c-3 has both categories OtherHardwood and OtherSoftwood

# 25     beech  c     3     OtherHardwood HK3                1
# 25     beech  c     3     OtherSoftwood HK1                1
# can I just merge the categories? or are sometimes the n_total summed by the different species?
# can be working if I would sum up the trees numbers over the heights categories 
# if there is only 'n_total == 1 ' I can simply merge; if there is more, I can split it manually




## Counts for planted data   -----------------------------------------------------
# counts of planted data is the part of total counts:
# the number of planted should never be higher than count_tot = total number of regeneration
df_regen_planted <-
  dat %>%
  dplyr::select(matches(paste(
    c(plot_info, plot_geo, 'Planted', 'uniqueID'), collapse = '|'
  ))) %>%
  dplyr::select(-all_of(plot_info)) %>%
  dplyr::select_if(function(col)
    all(
      col == .$uniqueID |
      col == .$gradient |
      col == .$exposure |
      is.numeric(col)
    )) %>% # select the numeric columns and the siteID (character)
  pivot_longer(!c(uniqueID, gradient, exposure),
               names_to = 'manag',
               values_to = 'n_planted') %>%          # convert to long format
  mutate(manag = gsub('Number_of_planted_individuals', 'planted', manag)) %>%   # replace string pattern to simplify names
  separate(manag, c('species', 'height_class', 'origin'), '_') %>%
  dplyr::select(-c('origin')) %>%
  separate(uniqueID, all_of(plot_info), '_') %>%
  filter(complete.cases(.))

dim(df_regen_planted)  # 56x9


## Get the damage data & position:
# can I see if teh damage was on planted or on naturally regenerated one?
df_regen_damaged <-
  dat %>% 
  dplyr::select(matches(paste(c(plot_info, plot_geo, 'Damage'), collapse = '|'))) %>%
  mutate(uniqueID = paste(trip_n,dom_sp,manag,sub_n, sep = '_' )) %>% 
    dplyr::select(-all_of(plot_info)) %>% 
    dplyr::select_if(function(col) all(
      col == .$uniqueID | 
      col == .$gradient | 
      col == .$exposure | 
      is.numeric(col))) %>% # select the numeric columns and the siteID (character)
    pivot_longer(!c(uniqueID, gradient, exposure), 
                 names_to = 'dam_manag', 
                 values_to = 'n_damage')  %>%          # convert to long format
   dplyr::mutate(dam_manag = str_replace_all(dam_manag, 
                                      c("leading_drive_damage" = "leader", 
                                        "other_damage"         = "other", 
                                        "combined_damage"      = "combined")))  %>% 
    dplyr::mutate(dam_manag = gsub('Number_of_', '', dam_manag)) %>% 
    separate(uniqueID, c('trip_n', 'dom_sp', 'manag', 'sub_n'), '_') %>% 
    separate(dam_manag, c('species', 'height_class', 'damage_place'), '_')  %>%
    filter(complete.cases(.)) %>% 
    filter(n_damage !=0)
  
  
dim(df_regen_damaged) # 842  10

# modify 'other species format' ----------------------------------------------
head(df_other_regen)
# Modify the table to merge it wit the other regeneration columsn

# get first the geo parameters per plot:
df_geo <- df_regen %>% 
  select(-c(height_class, species, n_total)) %>% 
  distinct() %>% 
  mutate(trip_n = as.character(trip_n),
         sub_n = as.character(sub_n))


# modify the other data table, add teh geo parameters;
# exclude the 'damaged' and planted category, as I do not need it at this step
df_other_regen2 <- 
  df_other_regen %>% 
  select(-c(species, General_remarks)) %>% 
  rename(species = Remarks_on_regeneration ) %>% 
    mutate(trip_n = as.character(trip_n),
           sub_n = as.character(sub_n)) %>% 
  right_join(df_geo) %>% # order the columns accordingly to regen
    select(all_of(colnames(df_regen)))
    
  

# Merge the regeneration data to know if damage was on planted/naturally regenerated trees?
# !!! test merge data planted & total: to see if the 'planted' counts is part of regeneration?
# df_reg_full <- 
#   df_regen %>% 
#   left_join(df_regen_planted)  %>% 
#   left_join(df_regen_damaged)  %>% 
#   filter(n_total !=0) %>%  # exclude 0 if no regeneration was collected
#   mutate(n_planted = replace_na(n_planted, 0)) %>% # convert all NaN to zeros
#   mutate(
#     species = case_when(
#       species == "OtherSoftwood" ~ "O_Soft",
#       species == "OtherHardwood" ~ "O_Hard",
#       TRUE ~ species
#     )) # %>% 


# 2022/11/08 - no need to currently exclude the planted species, or having the damaged tree excluded(included)
# simply exclude all of teh data from the 'regeneration' - of species == Other, and add rows from teh manual selection
df_reg_full <-
  df_regen %>%
    filter(!species %in% c('OtherSoftwood', 'OtherHardwood')) %>% 
    bind_rows(df_other_regen2) %>%  # replace by the individual species: now split by the latin names!
 # left_join(df_regen_planted)  %>%
  #left_join(df_regen_damaged)  %>%
  filter(n_total != 0) %>%  # exclude 0 if no regeneration was collected
  #mutate(n_planted = replace_na(n_planted, 0)) %>% # convert all NaN to zeros
  mutate(
    species = case_when(
      species == "OtherSoftwood" ~ "O_Soft",
      species == "OtherHardwood" ~ "O_Hard",
      TRUE ~ species
    )
  )  # now we have 27 species
 



# Export df regeneration --------------------------------------------------
fwrite(df_reg_full, outRegen)
 



## For Advanced regen: samplings  ---------------------------------------------------

# Extract the columns by the '1_Advanced_' indication and then merge them into one database:
# otherwise,not sure how to do it

# subsets counts for the Advanced regeneration (>2m up to 10 cm dbh)
# for now, max 8 advanced regen trees/subset

get_adv_regen <- function(x, ...) {
  #x = 2
  reg_name = paste(x, '_Advanced', sep = '')
  
  # Create a table to subset specific columns
  dat_reg <- dat %>% 
    dplyr::select(matches(paste(c(plot_info, plot_geo, reg_name), collapse = '|'))) %>% 
    dplyr::select(!matches(c('env_','_bin'))) %>% 
    mutate(uniqueID = paste(trip_n,dom_sp,manag,sub_n, sep = '_' )) %>% 
    dplyr::select(-c("trip_n","dom_sp","manag",'sub_n')) %>%
    mutate(tree_numb = x) %>% 
    filter(complete.cases(.)) # remove the rows that contains NA values
  
  # Rename the columns:
  colnames(dat_reg) <- c('gradient', 'exposure', 'species', 'DBH', 'height', 'uniqueID', 'tree_numb')
  
  # Return the df from teh function
  return(dat_reg)
 
}

##### Create a vectors of values to subset Advanced regen columns form the datatable ----------
x <- c(1:8)

# allply the function to get the whole list of the data
ls_advanced <- lapply(x, get_adv_regen)

# Convert dataframe from list into the single dataframe
df_advanced <- do.call(rbind, ls_advanced)


# Replace names of tree species:
df_advanced <- df_advanced %>%
  mutate(
    species = case_when(
      species == "Esche"        ~ "Ash",
      species == "Sonstiges NH" ~ "O_Soft",
      species == "Sonstiges LH" ~ "O_Hard",
      species == "Buche"        ~ "Beech" ,
      species == "Vogelbeere"   ~ "Rowan",
      species == "Bergahorn"    ~ "Maple",
      species == "Fichte"       ~ "Spruce",
      species == "Eiche"        ~ "Oak",
      species == "Kiefer"       ~ "Pine",
      species == "Birke"        ~ "Birch",
      species == "Weide"        ~ "Willow",
      species == "Tanne"        ~ "Fir"
    )
  )

# Replace 'tree number' (originally 1-8) by 1: 
# to corresponds to counts, not to the order of recording :

# check for the low values:
df_advanced %>% filter(height <200)  # change the values to cm in next step


#   species   DBH height uniqueID      tree_numb
#<chr>   <dbl>  <dbl> <chr>             <int>
#  1 Beech       9     10 64_pine_l_1           1
#  2 Beech       8     13 31_beech_c_10         1
#  3 Beech       8     18 32_beech_d_5          1
#  4 Beech       4      6 26_beech_c_1          2


df_advanced <- 
  df_advanced %>% 
  # replace the values: some have been recorded in meters instead of cm
  mutate(height = case_when(height< 200 ~ height*100,
                            TRUE ~ height)) %>% 
  mutate(height_class = "HK7") %>% 
  mutate(tree_numb = 1) %>% # # Replace 'tree number' (originally 1-8) by 1: 
                            # to corresponds to counts, not to the order of recording :
  rename(count = tree_numb) %>% 
  separate(uniqueID, c('trip_n', 'dom_sp', 'manag', 'sub_n'), '_')# %>% 
  #mutate(reg_height = 'saplings') %>% 
  #dplyr::select(colnames(df_regen))

  
#rm(df_advanced)

##### Rbind regeneration data into single dataframe: --------------------------------
#df_regen_fin <- rbind(df_regen, df_advanced2)

# Export the advanced regeneration table 
fwrite(df_advanced, outRegenAdvanced )







# Get mature trees ENVIRONMENT -------------------------------------------------


df_mature_trees_env <-
  dat %>% 
  dplyr::select(matches(paste(c(plot_info, plot_geo, 'env_'), collapse = '|'))) %>%
  dplyr::select(matches(paste(c(plot_info, plot_geo, 'MatureTree'), collapse = '|'))) %>%
  dplyr::select(-c("env_MatureTree_present_the_sectors" )) %>%
  drop_na() %>%  # some sample plots have nearest trees > 15m away 
  setnames(c(plot_info, 'gradient', 'exposure', 'orientation', 'species', 'DBH', 'distance', 'edge_tree' )) %>%
  mutate(species = case_when(species == "Esche"        ~ "Ash",
                                  species == "Sonstiges NH" ~ "O_Soft",
                                  species == "Sonstiges LH" ~ "O_Hard",
                                  species == "Buche"        ~ "Beech" ,
                                  species == "Vogelbeere"   ~ "Rowan",
                                  species == "Bergahorn"    ~ "Maple",
                                  species == "Fichte"       ~ "Spruce",
                                  species == "Eiche"        ~ "Oak",
                                  species == "Kiefer"       ~ "Pine",
                                  species == "Birke"        ~ "Birch",
                                  species == "Weide"        ~ "Willow",
                                  species == "Tanne"        ~ "Fir")) %>% 
  mutate(orientation = case_when(orientation == 'ost' ~ 'east',
                                 orientation == 'west'~ 'west',
                                 orientation == 'nord'~ 'north',
                                 orientation == 'sued'~ 'south')) %>% 
  mutate(trip_n = as.character(trip_n),
         sub_n = as.character(sub_n))



# Get the table of the nearest mature trees and the regeneration:
# the distance is measured from the plot center: minimal distance must be >100cm!! (max 15 m = 1500 cm)
df_mature_trees_env %>% 
  left_join(df_photo) %>% 
  filter(distance < 100 ) #%>% # & site == 'environment' 
 # select(trip_n, dom_sp, sub_n, species, DBH, photo_number, distance, edge_tree)




#### Save the mature trees dataset -------------------------------------------------
fwrite(df_mature_trees_env, outMatureENV )






# Get advanced trees ENVIRONMENT -------------------------------------------------

# Teh advanced trees in the ENV  do not have recorded the DBH!!! I can regress it from teh  
df_advanced_env <-
  dat %>% 
  dplyr::select(matches(paste(c(plot_info, plot_geo, 'env_'), collapse = '|'))) %>%
  dplyr::select(matches(paste(c(plot_info, plot_geo, 'Advanced_regeneration'), collapse = '|'))) %>%
  dplyr::select(-c("env_Advanced_regeneration_the_sectors" )) %>%
  #names()
  drop_na() %>%  # some sample plots have nearest trees > 15m away 
  setnames(c(plot_info, 'gradient', 'exposure', 'orientation', 'species', 'distance')) %>%
  mutate(species = case_when(species == "Esche"        ~ "Ash",
                                  species == "Sonstiges NH" ~ "O_Soft",
                                  species == "Sonstiges LH" ~ "O_Hard",
                                  species == "Buche"        ~ "Beech" ,
                                  species == "Vogelbeere"   ~ "Rowan",
                                  species == "Bergahorn"    ~ "Maple",
                                  species == "Fichte"       ~ "Spruce",
                                  species == "Eiche"        ~ "Oak",
                                  species == "Kiefer"       ~ "Pine",
                                  species == "Birke"        ~ "Birch",
                                  species == "Weide"        ~ "Willow",
                                  species == "Tanne"        ~ "Fir")) %>% 
  
  # filter(is.na(orientation))
  mutate(orientation = case_when(orientation == 'ost'~ 'east',
                                 orientation == 'west'~ 'west',
                                 orientation == 'nord'~ 'north',
                                 orientation == 'sued'~ 'south')) %>% 
  # distinct(orientation)
  mutate(trip_n = as.character(trip_n),
         sub_n = as.character(sub_n))


# Check teh distribution of values:
#hist(df_advanced_env$distance)
#df_advanced_env %>% 
#  ggplot(aes(distance), fill = 'white', col = 'black') +
#  geom_histogram(bins = 100) +
#  theme_bw() +
#  facet_grid(.~manag)


# # Get the list of the corresponding photos: from extremely low (< 100 cm) and high numbers (> 1500cm) 

df_advanced_env %>% 
  left_join(df_photo) %>% 
  filter(distance <100 & site == 'environment' ) %>% 
 select(trip_n, dom_sp, sub_n, species, exposure, photo_number, distance) # DBH, , edge_tree 




#### Save the mature trees dataset -------------------------------------------------
fwrite(df_advanced_env, outAdvancedENV)










# Identify which triplets have both photos and videos; 
# find which ones have mature trees in close proximity ----------------------------------------
head(df_photo)
head(df_video)
head(df_mature_trees_env)

df_mature_trees_env %>% 
  filter(distance < 100)

df_photo %>% 
  filter(trip_n == '28' & sub_n == '8')

# Export table for teh sites with photos, videos and nearest distant trees
# if nearest tree in environment is missing, then it is more then 15 m away from the plot center
df_photo_video_nearest <- df_photo %>% 
  filter(site == 'environment') %>%
  mutate(site = 'Surroundings') %>% 
  right_join(df_video, 
             by = c("trip_n", "dom_sp", "manag", "sub_n", "orientation", "site")) %>% 
  right_join(df_mature_trees_env, 
             by = c("trip_n", "dom_sp", "manag", "sub_n", "orientation")) %>% 
  drop_na()


df_photo_video_nearest %>% 
  filter(distance < 100)

fwrite(df_photo_video_nearest, outPhotoVideoNearestTree)





# Save selected dfs in R object: ------------------------------------------------------------
save(dat,                   # all raw data together  
     df_reg_full,           # full regeneration, with specified 'Other species' #included planted and damaged trees
    # df_regen,             # full plot regeneration
     df_ground,             # ground cover
     df_advanced,           # advanced regeneration PLOT, corrected distances
     df_advanced_env,       # advanced regeneration in ENV
     df_mature_trees_env,   # mature trees ENV
     df_mature_trees_plot,  # mature trees PLOT
     df_deadwood,           # get 4 types of deadwood in ENV   
     plot_counts_df,        # master table having all triplets and subsets structure
     file="outData/vegData.Rdata")

  

save(#dat,                   # all raw data together  
     df_reg_full,           # full regeneration, with specified 'Other species' #included planted and damaged trees
     # df_regen,             # full plot regeneration
     #df_ground,             # ground cover
     df_advanced,           # advanced regeneration PLOT, corrected distances
     df_advanced_env,       # advanced regeneration in ENV
     df_mature_trees_env,   # mature trees ENV
     df_mature_trees_plot,  # mature trees PLOT
    # df_deadwood,           # get 4 types of deadwood in ENV   
     plot_counts_df,        # master table having all triplets and subsets structure
     file="outData_share/vegData.Rdata")
